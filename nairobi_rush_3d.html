<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nairobi Rush 3D - Real-time Racing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        #gameCanvas { display: block; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function NairobiRush3D() {
            const mountRef = useRef(null);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [speed, setSpeed] = useState(0.15);
            const [gameOver, setGameOver] = useState(false);
            const [isPaused, setIsPaused] = useState(false);
            const [timeOfDay, setTimeOfDay] = useState('day');
            const [currentTime, setCurrentTime] = useState(new Date());
            const gameStateRef = useRef({
                playerLane: 1,
                traffic: [],
                buildings: [],
                roadSegments: [],
                distance: 0,
                lastSpawn: 0,
                crashed: false
            });

            useEffect(() => {
                const timer = setInterval(() => {
                    setCurrentTime(new Date());
                }, 1000);
                return () => clearInterval(timer);
            }, []);

            useEffect(() => {
                const hour = currentTime.getHours();
                if (hour >= 6 && hour < 18) {
                    setTimeOfDay('day');
                } else {
                    setTimeOfDay('night');
                }
            }, [currentTime]);

            useEffect(() => {
                if (!mountRef.current) return;

                // Scene setup
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(
                    timeOfDay === 'day' ? 0xffffff : 0x404040,
                    timeOfDay === 'day' ? 0.6 : 0.3
                );
                scene.add(ambientLight);

                const sunLight = new THREE.DirectionalLight(
                    timeOfDay === 'day' ? 0xffffff : 0x8888ff,
                    timeOfDay === 'day' ? 0.8 : 0.2
                );
                sunLight.position.set(10, 20, 10);
                sunLight.castShadow = true;
                scene.add(sunLight);

                // Sky/background
                scene.background = new THREE.Color(
                    timeOfDay === 'day' ? 0x87CEEB : 0x001a33
                );
                scene.fog = new THREE.Fog(
                    timeOfDay === 'day' ? 0x87CEEB : 0x001a33,
                    50,
                    200
                );

                // Player car (Kenyan flag colors)
                const playerCar = new THREE.Group();
                
                const carBody = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.8, 2.5),
                    new THREE.MeshPhongMaterial({ color: 0x22c55e })
                );
                carBody.castShadow = true;
                playerCar.add(carBody);

                const carTop = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 0.6, 1.5),
                    new THREE.MeshPhongMaterial({ color: 0x1e3a8a })
                );
                carTop.position.y = 0.7;
                carTop.castShadow = true;
                playerCar.add(carTop);

                // Wheels
                const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
                const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                const wheelPositions = [
                    [-0.7, -0.4, 1], [0.7, -0.4, 1],
                    [-0.7, -0.4, -1], [0.7, -0.4, -1]
                ];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(...pos);
                    playerCar.add(wheel);
                });

                // Kenyan flag on car
                const flagStripes = [
                    { color: 0x000000, y: 0.5 },
                    { color: 0xef4444, y: 0.35 },
                    { color: 0xffffff, y: 0.2 },
                    { color: 0x22c55e, y: 0.05 }
                ];
                flagStripes.forEach(stripe => {
                    const flag = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.05, 0.01),
                        new THREE.MeshPhongMaterial({ color: stripe.color })
                    );
                    flag.position.set(0, stripe.y, 1.3);
                    playerCar.add(flag);
                });

                playerCar.position.set(0, 0, -5);
                scene.add(playerCar);

                // Road
                const roadWidth = 12;
                const laneWidth = roadWidth / 3;
                
                const createRoadSegment = (z) => {
                    const road = new THREE.Mesh(
                        new THREE.PlaneGeometry(roadWidth, 20),
                        new THREE.MeshPhongMaterial({ color: 0x2d3748 })
                    );
                    road.rotation.x = -Math.PI / 2;
                    road.position.set(0, -0.5, z);
                    road.receiveShadow = true;
                    return road;
                };

                // Initial road segments
                for (let i = 0; i < 20; i++) {
                    const segment = createRoadSegment(i * 20);
                    scene.add(segment);
                    gameStateRef.current.roadSegments.push(segment);
                }

                // Road markings
                const createRoadMarking = (x, z) => {
                    const marking = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 0.01, 2),
                        new THREE.MeshBasicMaterial({ color: 0xfef08a })
                    );
                    marking.position.set(x, -0.49, z);
                    return marking;
                };

                const markings = [];
                for (let i = 0; i < 50; i++) {
                    const z = i * 5;
                    markings.push(createRoadMarking(-laneWidth, z));
                    markings.push(createRoadMarking(laneWidth, z));
                    markings.forEach(m => scene.add(m));
                }

                // Sidewalks
                const createSidewalk = (x, z) => {
                    const sidewalk = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 0.3, 20),
                        new THREE.MeshPhongMaterial({ color: 0x9ca3af })
                    );
                    sidewalk.position.set(x, -0.35, z);
                    return sidewalk;
                };

                for (let i = 0; i < 20; i++) {
                    scene.add(createSidewalk(-9, i * 20));
                    scene.add(createSidewalk(9, i * 20));
                }

                // Buildings (Nairobi landmarks)
                const createBuilding = (x, z, height, color, name) => {
                    const building = new THREE.Group();
                    
                    const main = new THREE.Mesh(
                        new THREE.BoxGeometry(4, height, 4),
                        new THREE.MeshPhongMaterial({ color })
                    );
                    main.position.y = height / 2 - 0.5;
                    main.castShadow = true;
                    building.add(main);

                    // Windows
                    for (let i = 0; i < height; i += 1.5) {
                        for (let j = -1; j <= 1; j++) {
                            const window = new THREE.Mesh(
                                new THREE.BoxGeometry(0.4, 0.6, 0.1),
                                new THREE.MeshBasicMaterial({ 
                                    color: timeOfDay === 'day' ? 0x4a90e2 : 0xfbbf24 
                                })
                            );
                            window.position.set(j * 1.2, i, 2.05);
                            building.add(window);
                        }
                    }

                    building.position.set(x, 0, z);
                    return building;
                };

                const buildingColors = [0x1e40af, 0x7c3aed, 0xdc2626, 0x059669, 0xd97706];
                for (let i = 0; i < 30; i++) {
                    const side = Math.random() < 0.5 ? -15 : 15;
                    const height = 8 + Math.random() * 12;
                    const z = i * 25 + Math.random() * 10;
                    const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    const building = createBuilding(side, z, height, color);
                    scene.add(building);
                    gameStateRef.current.buildings.push(building);
                }

                // Traffic car creation
                const createTrafficCar = (lane, z, isMatatu = false) => {
                    const car = new THREE.Group();
                    
                    const colors = isMatatu 
                        ? [0xfbbf24, 0xf59e0b] 
                        : [0xef4444, 0x3b82f6, 0x8b5cf6, 0xec4899, 0x06b6d4];
                    
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 0.8, 2.5),
                        new THREE.MeshPhongMaterial({ 
                            color: colors[Math.floor(Math.random() * colors.length)] 
                        })
                    );
                    body.castShadow = true;
                    car.add(body);

                    const top = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, 0.6, 1.5),
                        new THREE.MeshPhongMaterial({ color: 0x1e3a8a })
                    );
                    top.position.y = 0.7;
                    car.add(top);

                    // Add wheels
                    wheelPositions.forEach(pos => {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(...pos);
                        car.add(wheel);
                    });

                    const x = (lane - 1) * laneWidth;
                    car.position.set(x, 0, z);
                    car.userData = { lane, speed: 0.05 + Math.random() * 0.05, isMatatu };
                    
                    return car;
                };

                // Camera position
                camera.position.set(0, 8, -10);
                camera.lookAt(0, 0, 0);

                // Controls
                const handleKeyDown = (e) => {
                    if (gameOver) return;
                    const state = gameStateRef.current;

                    if (e.key === ' ') {
                        e.preventDefault();
                        setIsPaused(prev => !prev);
                        return;
                    }

                    if (e.key === 'ArrowLeft' && state.playerLane > 0) {
                        state.playerLane--;
                    } else if (e.key === 'ArrowRight' && state.playerLane < 2) {
                        state.playerLane++;
                    }
                };

                window.addEventListener('keydown', handleKeyDown);

                // Animation loop
                let frameCount = 0;
                const animate = () => {
                    if (gameOver || isPaused) {
                        requestAnimationFrame(animate);
                        renderer.render(scene, camera);
                        return;
                    }

                    frameCount++;
                    const state = gameStateRef.current;

                    // Move player to lane
                    const targetX = (state.playerLane - 1) * laneWidth;
                    playerCar.position.x += (targetX - playerCar.position.x) * 0.1;

                    // Move road and markings
                    gameStateRef.current.roadSegments.forEach(segment => {
                        segment.position.z -= speed;
                        if (segment.position.z < -20) {
                            segment.position.z += 400;
                        }
                    });

                    markings.forEach(marking => {
                        marking.position.z -= speed;
                        if (marking.position.z < -20) {
                            marking.position.z += 250;
                        }
                    });

                    // Move buildings
                    gameStateRef.current.buildings.forEach(building => {
                        building.position.z -= speed;
                        if (building.position.z < -50) {
                            building.position.z += 750;
                        }
                    });

                    // Spawn traffic
                    if (frameCount - state.lastSpawn > 80 / speed) {
                        const lane = Math.floor(Math.random() * 3);
                        const isMatatu = Math.random() < 0.3;
                        const car = createTrafficCar(lane, 100, isMatatu);
                        scene.add(car);
                        state.traffic.push(car);
                        state.lastSpawn = frameCount;
                    }

                    // Update traffic
                    state.traffic = state.traffic.filter(car => {
                        car.position.z -= speed + car.userData.speed;

                        // Collision detection
                        const dx = Math.abs(car.position.x - playerCar.position.x);
                        const dz = Math.abs(car.position.z - playerCar.position.z);
                        
                        if (dx < 1.5 && dz < 3 && !state.crashed) {
                            state.crashed = true;
                            setGameOver(true);
                            if (score > highScore) {
                                setHighScore(score);
                            }
                        }

                        if (car.position.z < -20) {
                            scene.remove(car);
                            return false;
                        }
                        return true;
                    });

                    // Update score
                    state.distance += speed;
                    if (state.distance >= 1) {
                        setScore(prev => prev + 1);
                        state.distance = 0;
                        
                        if (score % 100 === 0 && speed < 0.4) {
                            setSpeed(prev => prev + 0.02);
                        }
                    }

                    renderer.render(scene, camera);
                    requestAnimationFrame(animate);
                };

                animate();

                // Cleanup
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                    renderer.dispose();
                };
            }, [gameOver, isPaused, speed, score, highScore, timeOfDay]);

            const resetGame = () => {
                gameStateRef.current = {
                    playerLane: 1,
                    traffic: [],
                    buildings: [],
                    roadSegments: [],
                    distance: 0,
                    lastSpawn: 0,
                    crashed: false
                };
                setScore(0);
                setSpeed(0.15);
                setGameOver(false);
                setIsPaused(false);
            };

            return (
                <div className="relative w-screen h-screen">
                    <div ref={mountRef} className="w-full h-full" />
                    
                    {/* HUD */}
                    <div className="absolute top-0 left-0 right-0 p-6 pointer-events-none">
                        <div className="max-w-4xl mx-auto">
                            <div className="flex justify-between items-start">
                                <div className="bg-black bg-opacity-70 text-white rounded-lg p-4 backdrop-blur-sm">
                                    <div className="text-3xl font-bold mb-1">{score}m</div>
                                    <div className="text-sm text-gray-300">Distance</div>
                                </div>

                                <div className="bg-black bg-opacity-70 text-white rounded-lg p-4 backdrop-blur-sm">
                                    <div className="text-lg font-bold mb-2">üá∞üá™ NAIROBI CBD</div>
                                    <div className="text-sm">
                                        {currentTime.toLocaleTimeString('en-KE', { 
                                            hour: '2-digit', 
                                            minute: '2-digit',
                                            timeZone: 'Africa/Nairobi'
                                        })}
                                    </div>
                                    <div className="text-xs text-gray-300 mt-1">
                                        {timeOfDay === 'day' ? '‚òÄÔ∏è Day' : 'üåô Night'}
                                    </div>
                                </div>

                                <div className="bg-black bg-opacity-70 text-white rounded-lg p-4 backdrop-blur-sm">
                                    <div className="text-3xl font-bold mb-1">{highScore}m</div>
                                    <div className="text-sm text-gray-300">Best</div>
                                </div>
                            </div>

                            <div className="mt-4 bg-black bg-opacity-70 text-white rounded-lg p-3 backdrop-blur-sm inline-block">
                                <div className="text-sm">Speed: {(speed * 100).toFixed(0)} km/h</div>
                            </div>
                        </div>
                    </div>

                    {/* Pause overlay */}
                    {isPaused && !gameOver && (
                        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 backdrop-blur-sm pointer-events-none">
                            <div className="bg-yellow-400 text-black p-8 rounded-2xl shadow-2xl text-center">
                                <p className="text-4xl font-bold mb-2">‚è∏Ô∏è PAUSED</p>
                                <p className="text-lg">Press SPACE to continue</p>
                            </div>
                        </div>
                    )}

                    {/* Game Over overlay */}
                    {gameOver && (
                        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 backdrop-blur-sm">
                            <div className="bg-gradient-to-br from-red-600 to-red-800 text-white p-10 rounded-2xl shadow-2xl text-center max-w-md pointer-events-auto">
                                <p className="text-5xl font-bold mb-4">üí• CRASH!</p>
                                <p className="text-2xl mb-2">Distance: {score}m</p>
                                <p className="text-xl mb-6">Best: {highScore}m</p>
                                {score === highScore && score > 0 && (
                                    <p className="text-lg mb-4 text-yellow-300">üèÜ New Record!</p>
                                )}
                                <button
                                    onClick={resetGame}
                                    className="bg-white text-red-600 font-bold py-4 px-8 rounded-full shadow-lg transition-all hover:scale-105 hover:bg-gray-100"
                                >
                                    üîÑ Drive Again
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Controls info */}
                    <div className="absolute bottom-0 left-0 right-0 p-6 pointer-events-none">
                        <div className="max-w-4xl mx-auto">
                            <div className="bg-black bg-opacity-70 text-white rounded-lg p-4 backdrop-blur-sm text-center">
                                <p className="text-sm">
                                    ‚¨ÖÔ∏è‚û°Ô∏è Arrow Keys to change lanes ‚Ä¢ SPACE to pause ‚Ä¢ Avoid traffic!
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<NairobiRush3D />, document.getElementById('root'));
    </script>
</body>
</html>